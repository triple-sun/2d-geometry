/**
 * Represents a value that might or might not be.
 * The API is inspired from Option in scala. You operate on this type
 * like you would on an array, allowing you to chain possible mappings operations
 * that will happen if a value is defined (of type Some),
 * and will not happen if the value is undefined (of type None).
 */
export declare abstract class Optional<T extends NonNullable<any>> {
    static of<T>(value: T | undefined): Optional<T>;
    /**
     * Maps the contained value if exists using the given function.
     * @param f
     */
    abstract map<A extends NonNullable<any>>(f: (val: T) => A): Optional<A>;
    /**
     * Maps the contained value with a function that returns Optional<T>.
     * It functions like map, except it also flattens so that you don't
     * get a nested Optional<Optional<T>>
     * @param f
     */
    abstract flatMap<A extends NonNullable<any>>(f: (val: T) => Optional<A>): Optional<A>;
    /**
     * Filters out value if it doesn't fulfill predicate. A Some value
     * then becomes None
     * @param predicate
     */
    abstract filter(predicate: (val: T) => boolean): Optional<T>;
    /**
     * Performs the operation on the given value, then return the option again.
     * This is unlike the Scala API, where Unit is returned. here it allows
     * for additional chaining of mappings etc.
     * @param f
     */
    abstract foreach(f: (val: T) => void): Optional<T>;
    /**
     * Gets get value if exists, otherwise throws exception.
     */
    abstract get(): T;
    /**
     * Gets the value if exists, otherwise returns inserted value.
     * @param val
     */
    abstract getOrElse(val: T): T;
    /**
     * If this optional isn't some, the or statement will be evaluated.
     * @param func
     * Function that will be called if this is none.
     */
    abstract or(func: () => Optional<T>): Optional<T>;
    /**
     * Check if a value exists
     */
    abstract isEmpty(): boolean;
    /**
     * Checks if a value doesn't exist.
     */
    abstract nonEmpty(): boolean;
}
declare class None extends Optional<NonNullable<any>> {
    static nil: None;
    map<A extends NonNullable<any>>(f: (val: NonNullable<any>) => A): Optional<A>;
    filter(f: (val: NonNullable<any>) => boolean): Optional<NonNullable<any>>;
    nonEmpty(): boolean;
    flatMap<A extends NonNullable<any>>(f: (val: NonNullable<any>) => Optional<A>): Optional<A>;
    get(): NonNullable<any>;
    getOrElse(val: NonNullable<any>): NonNullable<any>;
    or(func: () => Optional<NonNullable<any>>): Optional<NonNullable<any>>;
    isEmpty(): boolean;
    foreach(f: (val: NonNullable<any>) => void): Optional<NonNullable<any>>;
}
declare class Some<T extends NonNullable<any>> extends Optional<T> {
    private value;
    constructor(value: T);
    map<A extends NonNullable<any>>(f: (val: T) => A): Optional<A>;
    nonEmpty(): boolean;
    filter(f: (val: T) => boolean): Optional<T>;
    foreach(f: (val: T) => void): Optional<T>;
    flatMap<A extends NonNullable<any>>(f: (val: T) => Optional<A>): Optional<A>;
    get(): T;
    getOrElse(val: T): T;
    or(func: () => Optional<T>): Optional<T>;
    isEmpty(): boolean;
}
/**
 * Returns the value wrapped in Some.
 * @param value
 */
export declare function some<T extends NonNullable<any>>(value: T): Some<T>;
/**
 * Returns the value wrapped in Optional
 * @param value
 */
export declare function optional<T>(value: T | undefined): Optional<T>;
/**
 * Represents undefined.
 */
export declare const none: None;
export {};
//# sourceMappingURL=Optional.d.ts.map